{
  "version": 3,
  "sources": ["../../@vis.gl/react-google-maps/src/libraries/google-maps-api-loader.ts", "../../@vis.gl/react-google-maps/src/components/api-provider.tsx", "../../@vis.gl/react-google-maps/src/hooks/use-api-loading-status.ts", "../../@vis.gl/react-google-maps/src/hooks/use-api-is-loaded.ts", "../../@vis.gl/react-google-maps/src/libraries/errors.ts", "../../@vis.gl/react-google-maps/src/libraries/use-callback-ref.tsx", "../../@vis.gl/react-google-maps/src/components/map/use-internal-camera-state.ts", "../../@vis.gl/react-google-maps/src/components/map/use-map-events.ts", "../../@vis.gl/react-google-maps/src/libraries/is-lat-lng-literal.ts", "../../@vis.gl/react-google-maps/src/components/map/use-map-options.ts", "../../@vis.gl/react-google-maps/src/components/map/use-deckgl-camera-update.ts", "../../@vis.gl/react-google-maps/src/components/map/index.tsx", "../../@vis.gl/react-google-maps/src/hooks/use-maps-library.ts", "../../@vis.gl/react-google-maps/src/components/advanced-marker.tsx", "../../@vis.gl/react-google-maps/src/components/info-window.tsx", "../../@vis.gl/react-google-maps/src/hooks/use-map.ts", "../../@vis.gl/react-google-maps/src/components/map-control.tsx", "../../@vis.gl/react-google-maps/src/components/marker.tsx", "../../@vis.gl/react-google-maps/src/components/pin.tsx", "../../@vis.gl/react-google-maps/src/hooks/autocomplete.ts", "../../@vis.gl/react-google-maps/src/libraries/assert-not-null.ts", "../../@vis.gl/react-google-maps/src/hooks/directions-service.ts", "../../@vis.gl/react-google-maps/src/hooks/street-view-panorama.ts", "../../@vis.gl/react-google-maps/src/libraries/limit-tilt-range.ts"],
  "sourcesContent": ["export type ApiParams = {\n  key: string;\n  v?: string;\n  language?: string;\n  region?: string;\n  libraries?: string;\n  solutionChannel?: string;\n  authReferrerPolicy?: string;\n};\n\n// Declare global maps callback function\ndeclare global {\n  interface Window {\n    __googleMapsCallback__?: () => void;\n    __googleMapsApiParams__?: string;\n  }\n}\n\nconst MAPS_API_BASE_URL = 'https://maps.googleapis.com/maps/api/js';\n\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */\nexport class GoogleMapsApiLoader {\n  /**\n   * Loads the Google Maps API with the specified parameters.\n   * Since the maps library can only be loaded once per page, this will\n   * produce a warning when called multiple times with different\n   * parameters.\n   *\n   * The returned promise resolves when loading completes\n   * and rejects in case of an error or when the loading was aborted.\n   * @param params\n   */\n  static async load(params: ApiParams): Promise<void> {\n    const libraries = params.libraries ? params.libraries.split(',') : [];\n    const serializedParams = this.serializeParams(params);\n\n    if (!window.google?.maps?.importLibrary) {\n      window.__googleMapsApiParams__ = serializedParams;\n      this.initImportLibrary(params);\n    }\n\n    if (\n      window.__googleMapsApiParams__ &&\n      window.__googleMapsApiParams__ !== serializedParams\n    ) {\n      console.warn(\n        `The maps API has already been loaded with different ` +\n          `parameters and will not be loaded again. Refresh the page for ` +\n          `new values to have effect.`\n      );\n    }\n\n    for (const lib of ['maps', ...libraries]) {\n      await google.maps.importLibrary(lib);\n    }\n  }\n\n  private static serializeParams(params: ApiParams): string {\n    return [\n      params.v,\n      params.key,\n      params.language,\n      params.region,\n      params.authReferrerPolicy,\n      params.solutionChannel\n    ].join('/');\n  }\n\n  private static initImportLibrary(params: ApiParams) {\n    if (!window.google) window.google = {} as never;\n    if (!window.google.maps) window.google.maps = {} as never;\n\n    if (window.google.maps['importLibrary']) {\n      console.warn('initImportLibrary can only be called once.', params);\n\n      return;\n    }\n\n    let apiPromise: Promise<void> | null = null;\n\n    const loadApi = (library: string) => {\n      if (apiPromise) return apiPromise;\n\n      apiPromise = new Promise((resolve, reject) => {\n        const scriptElement = document.createElement('script');\n        const urlParams = new URLSearchParams();\n\n        for (const [key, value] of Object.entries(params)) {\n          const urlParamName = key.replace(\n            /[A-Z]/g,\n            t => '_' + t[0].toLowerCase()\n          );\n          urlParams.set(urlParamName, value);\n        }\n        urlParams.set('libraries', library);\n        urlParams.set('callback', '__googleMapsCallback__');\n        scriptElement.src = MAPS_API_BASE_URL + `?` + urlParams.toString();\n\n        window.__googleMapsCallback__ = resolve;\n\n        scriptElement.onerror = () =>\n          reject(new Error('The Google Maps JavaScript API could not load.'));\n        scriptElement.nonce =\n          (document.querySelector('script[nonce]') as HTMLScriptElement)\n            ?.nonce || '';\n\n        document.head.append(scriptElement);\n      });\n\n      return apiPromise;\n    };\n\n    // for the first load we declare an importLibrary function that will\n    // be overwritten once the api is loaded.\n    google.maps.importLibrary = libraryName =>\n      loadApi(libraryName).then(() => google.maps.importLibrary(libraryName));\n  }\n}\n", "import React, {\n  PropsWithChildren,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useState\n} from 'react';\n\nimport {GoogleMapsApiLoader} from '../libraries/google-maps-api-loader';\n\nexport enum APILoadingStatus {\n  NOT_LOADED = 'NOT_LOADED',\n  LOADING = 'LOADING',\n  LOADED = 'LOADED',\n  FAILED = 'FAILED'\n}\n\nconst {NOT_LOADED, LOADING, LOADED, FAILED} = APILoadingStatus;\n\ntype ImportLibraryFunction = typeof google.maps.importLibrary;\ntype GoogleMapsLibrary = Awaited<ReturnType<ImportLibraryFunction>>;\ntype LoadedLibraries = {[name: string]: GoogleMapsLibrary};\n\nexport interface APIProviderContextValue {\n  status: APILoadingStatus;\n  loadedLibraries: LoadedLibraries;\n  importLibrary: typeof google.maps.importLibrary;\n  mapInstances: Record<string, google.maps.Map>;\n  addMapInstance: (map: google.maps.Map, id?: string) => void;\n  removeMapInstance: (id?: string) => void;\n  clearMapInstances: () => void;\n}\n\nexport const APIProviderContext =\n  React.createContext<APIProviderContextValue | null>(null);\n\nexport type APIProviderProps = {\n  /**\n   * apiKey must be provided to load the Google Maps JavaScript API. To create an API key, see: https://developers.google.com/maps/documentation/javascript/get-api-key\n   * Part of:\n   */\n  apiKey: string;\n  /**\n   * A custom id to reference the script tag can be provided. The default is set to 'google-maps-api'\n   * @default 'google-maps-api'\n   */\n  libraries?: Array<string>;\n  /**\n   * A specific version of the Google Maps JavaScript API can be used.\n   * Read more about versioning: https://developers.google.com/maps/documentation/javascript/versions\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  version?: string;\n  /**\n   * Sets the map to a specific region.\n   * Read more about localizing the Map: https://developers.google.com/maps/documentation/javascript/localization\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  region?: string;\n  /**\n   * Use a specific language for the map.\n   * Read more about localizing the Map: https://developers.google.com/maps/documentation/javascript/localization\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  language?: string;\n  /**\n   * auth_referrer_policy can be set to 'origin'.\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  authReferrerPolicy?: string;\n  /**\n   * A function that can be used to execute code after the Google Maps JavaScript API has been loaded.\n   */\n  onLoad?: () => void;\n};\n\n/**\n * local hook to manage access to map-instances.\n */\nfunction useMapInstances() {\n  const [mapInstances, setMapInstances] = useState<\n    Record<string, google.maps.Map>\n  >({});\n\n  const addMapInstance = (mapInstance: google.maps.Map, id = 'default') => {\n    setMapInstances(instances => ({...instances, [id]: mapInstance}));\n  };\n\n  const removeMapInstance = (id = 'default') => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setMapInstances(({[id]: _, ...remaining}) => remaining);\n  };\n\n  const clearMapInstances = () => {\n    setMapInstances({});\n  };\n\n  return {mapInstances, addMapInstance, removeMapInstance, clearMapInstances};\n}\n\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */\nfunction useGoogleMapsApiLoader(props: APIProviderProps) {\n  const {onLoad, apiKey, libraries = [], ...otherApiParams} = props;\n\n  const [status, setStatus] = useState<APILoadingStatus>(NOT_LOADED);\n  const [loadedLibraries, addLoadedLibrary] = useReducer(\n    (\n      loadedLibraries: LoadedLibraries,\n      action: {name: keyof LoadedLibraries; value: LoadedLibraries[string]}\n    ) => {\n      return {...loadedLibraries, [action.name]: action.value};\n    },\n    {}\n  );\n\n  const librariesString = useMemo(() => libraries?.join(','), [libraries]);\n  const serializedParams = useMemo(\n    () => JSON.stringify(otherApiParams),\n    [otherApiParams]\n  );\n\n  const importLibrary: typeof google.maps.importLibrary = useCallback(\n    async (name: string) => {\n      if (loadedLibraries[name]) {\n        return loadedLibraries[name];\n      }\n\n      if (!google?.maps?.importLibrary) {\n        throw new Error(\n          '[api-provider-internal] importLibrary was called before ' +\n            'google.maps.importLibrary was defined.'\n        );\n      }\n\n      const res = await window.google.maps.importLibrary(name);\n      addLoadedLibrary({name, value: res});\n\n      return res;\n    },\n    [loadedLibraries]\n  );\n\n  useEffect(\n    () => {\n      setStatus(LOADING);\n\n      (async () => {\n        try {\n          await GoogleMapsApiLoader.load({\n            key: apiKey,\n            libraries: librariesString,\n            ...otherApiParams\n          });\n\n          setStatus(LOADED);\n\n          for (const name of ['core', 'maps', ...libraries]) {\n            await importLibrary(name);\n          }\n\n          if (onLoad) {\n            onLoad();\n          }\n        } catch (error) {\n          console.error('<ApiProvider> failed to load Google Maps API', error);\n          setStatus(FAILED);\n        }\n      })();\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [apiKey, librariesString, serializedParams]\n  );\n\n  return {\n    status,\n    loadedLibraries,\n    importLibrary\n  };\n}\n\n/**\n * Component to wrap the Google Maps React components and load the Google Maps JavaScript API\n */\nexport const APIProvider = (\n  props: PropsWithChildren<APIProviderProps>\n): ReactElement | null => {\n  const {children, ...loaderProps} = props;\n  const {mapInstances, addMapInstance, removeMapInstance, clearMapInstances} =\n    useMapInstances();\n\n  const {status, loadedLibraries, importLibrary} =\n    useGoogleMapsApiLoader(loaderProps);\n\n  return (\n    <APIProviderContext.Provider\n      value={{\n        mapInstances,\n        addMapInstance,\n        removeMapInstance,\n        clearMapInstances,\n        status,\n        loadedLibraries,\n        importLibrary\n      }}>\n      {children}\n    </APIProviderContext.Provider>\n  );\n};\n", "import {useContext} from 'react';\nimport {APILoadingStatus, APIProviderContext} from '../components/api-provider';\n\nexport function useApiLoadingStatus(): APILoadingStatus {\n  return useContext(APIProviderContext)?.status || APILoadingStatus.NOT_LOADED;\n}\n", "import {APILoadingStatus} from '../components/api-provider';\nimport {useApiLoadingStatus} from './use-api-loading-status';\n/**\n * Hook to check if the Google Maps API is loaded\n */\nexport function useApiIsLoaded(): boolean {\n  const status = useApiLoadingStatus();\n\n  return status === APILoadingStatus.LOADED;\n}\n", "const shownMessages = new Set();\n\nexport function logErrorOnce(...args: Parameters<typeof console.error>) {\n  const key = JSON.stringify(args);\n\n  if (!shownMessages.has(key)) {\n    shownMessages.add(key);\n\n    console.error(...args);\n  }\n}\n", "import {Ref, useCallback, useState} from 'react';\n\nexport function useCallbackRef<T>() {\n  const [el, setEl] = useState<T | null>(null);\n  const ref = useCallback((value: T) => setEl(value), [setEl]);\n\n  return [el, ref as Ref<T>] as const;\n}\n", "import {MutableRefObject, useRef} from 'react';\nimport {MapCameraChangedEvent, MapEvent} from './use-map-events';\n\nexport type InternalCameraState = {\n  center: google.maps.LatLngLiteral;\n  heading: number;\n  tilt: number;\n  zoom: number;\n};\n\nexport type InternalCameraStateRef = MutableRefObject<InternalCameraState>;\n\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is updated by `trackDispatchedEvent` and used in `useMapOptions`.\n */\nexport function useInternalCameraState(): InternalCameraStateRef {\n  return useRef<InternalCameraState>({\n    center: {lat: 0, lng: 0},\n    heading: 0,\n    tilt: 0,\n    zoom: 0\n  });\n}\n\n/**\n * Records camera data from the last event dispatched to the React application\n * in a mutable `IternalCameraStateRef`.\n * This data can then be used to prevent feeding these values back to the\n * map-instance when a typical \"controlled component\" setup (state variable is\n * fed into and updated by the map).\n */\nexport function trackDispatchedEvent(\n  ev: MapEvent,\n  cameraStateRef: InternalCameraStateRef\n) {\n  const cameraEvent = ev as MapCameraChangedEvent;\n\n  // we're only interested in the camera-events here\n  if (!cameraEvent.detail.center) return;\n  const {center, zoom, heading, tilt} = cameraEvent.detail;\n\n  cameraStateRef.current.center = center;\n  cameraStateRef.current.heading = heading;\n  cameraStateRef.current.tilt = tilt;\n  cameraStateRef.current.zoom = zoom;\n}\n", "import {useEffect} from 'react';\nimport {\n  InternalCameraStateRef,\n  trackDispatchedEvent\n} from './use-internal-camera-state';\n\n/**\n * Handlers for all events that could be emitted by map-instances.\n */\nexport type MapEventProps = Partial<{\n  // map view state events\n  onBoundsChanged: (event: MapCameraChangedEvent) => void;\n  onCenterChanged: (event: MapCameraChangedEvent) => void;\n  onHeadingChanged: (event: MapCameraChangedEvent) => void;\n  onTiltChanged: (event: MapCameraChangedEvent) => void;\n  onZoomChanged: (event: MapCameraChangedEvent) => void;\n  onProjectionChanged: (event: MapCameraChangedEvent) => void;\n\n  // mouse / touch / pointer events\n  onClick: (event: MapMouseEvent) => void;\n  onDblclick: (event: MapMouseEvent) => void;\n  onContextmenu: (event: MapMouseEvent) => void;\n  onMousemove: (event: MapMouseEvent) => void;\n  onMouseover: (event: MapMouseEvent) => void;\n  onMouseout: (event: MapMouseEvent) => void;\n  onDrag: (event: MapEvent) => void;\n  onDragend: (event: MapEvent) => void;\n  onDragstart: (event: MapEvent) => void;\n\n  // loading events\n  onTilesLoaded: (event: MapEvent) => void;\n  onIdle: (event: MapEvent) => void;\n\n  // configuration events\n  onIsFractionalZoomEnabledChanged: (event: MapEvent) => void;\n  onMapCapabilitiesChanged: (event: MapEvent) => void;\n  onMapTypeIdChanged: (event: MapEvent) => void;\n  onRenderingTypeChanged: (event: MapEvent) => void;\n}>;\n\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */\nexport function useMapEvents(\n  map: google.maps.Map | null,\n  cameraStateRef: InternalCameraStateRef,\n  props: MapEventProps\n) {\n  // note: calling a useEffect hook from within a loop is prohibited by the\n  // rules of hooks, but it's ok here since it's unconditional and the number\n  // and order of iterations is always strictly the same.\n  // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n\n  for (const propName of eventPropNames) {\n    // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n    //   a proper solution seems way too complicated right now\n    const handler = props[propName] as (ev: MapEvent) => void;\n    const eventType = propNameToEventType[propName];\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!map) return;\n      if (!handler) return;\n\n      const listener = map.addListener(\n        eventType,\n        (ev?: google.maps.MapMouseEvent | google.maps.IconMouseEvent) => {\n          const mapEvent = createMapEvent(eventType, map, ev);\n\n          trackDispatchedEvent(mapEvent, cameraStateRef);\n          handler(mapEvent);\n        }\n      );\n\n      return () => listener.remove();\n    }, [map, cameraStateRef, eventType, handler]);\n  }\n}\n\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */\nfunction createMapEvent(\n  type: string,\n  map: google.maps.Map,\n  srcEvent?: google.maps.MapMouseEvent | google.maps.IconMouseEvent\n): MapEvent {\n  const ev: MapEvent = {\n    type,\n    map,\n    detail: {},\n    stoppable: false,\n    stop: () => {}\n  };\n\n  if (cameraEventTypes.includes(type)) {\n    const camEvent = ev as MapCameraChangedEvent;\n\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n      console.warn(\n        '[createEvent] at least one of the values from the map ' +\n          'returned undefined. This is not expected to happen. Please ' +\n          'report an issue at https://github.com/visgl/react-google-maps/issues/new'\n      );\n    }\n\n    camEvent.detail = {\n      center: center?.toJSON() || {lat: 0, lng: 0},\n      zoom: zoom as number,\n      heading: heading as number,\n      tilt: tilt as number,\n      bounds: bounds?.toJSON() || {\n        north: 90,\n        east: 180,\n        south: -90,\n        west: -180\n      }\n    };\n\n    return camEvent;\n  } else if (mouseEventTypes.includes(type)) {\n    if (!srcEvent)\n      throw new Error('[createEvent] mouse events must provide a srcEvent');\n    const mouseEvent = ev as MapMouseEvent;\n\n    mouseEvent.domEvent = srcEvent.domEvent;\n    mouseEvent.stoppable = true;\n    mouseEvent.stop = () => srcEvent.stop();\n\n    mouseEvent.detail = {\n      latLng: srcEvent.latLng?.toJSON() || null,\n      placeId: (srcEvent as google.maps.IconMouseEvent).placeId\n    };\n\n    return mouseEvent;\n  }\n\n  return ev;\n}\n\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */\nconst propNameToEventType: {[prop in keyof Required<MapEventProps>]: string} = {\n  onBoundsChanged: 'bounds_changed',\n  onCenterChanged: 'center_changed',\n  onClick: 'click',\n  onContextmenu: 'contextmenu',\n  onDblclick: 'dblclick',\n  onDrag: 'drag',\n  onDragend: 'dragend',\n  onDragstart: 'dragstart',\n  onHeadingChanged: 'heading_changed',\n  onIdle: 'idle',\n  onIsFractionalZoomEnabledChanged: 'isfractionalzoomenabled_changed',\n  onMapCapabilitiesChanged: 'mapcapabilities_changed',\n  onMapTypeIdChanged: 'maptypeid_changed',\n  onMousemove: 'mousemove',\n  onMouseout: 'mouseout',\n  onMouseover: 'mouseover',\n  onProjectionChanged: 'projection_changed',\n  onRenderingTypeChanged: 'renderingtype_changed',\n  onTilesLoaded: 'tilesloaded',\n  onTiltChanged: 'tilt_changed',\n  onZoomChanged: 'zoom_changed'\n} as const;\n\nconst cameraEventTypes = [\n  'bounds_changed',\n  'center_changed',\n  'heading_changed',\n  'projection_changed',\n  'tilt_changed',\n  'zoom_changed'\n];\n\nconst mouseEventTypes = [\n  'click',\n  'contextmenu',\n  'dblclick',\n  'mousemove',\n  'mouseout',\n  'mouseover'\n];\n\ntype MapEventPropName = keyof MapEventProps;\nconst eventPropNames = Object.keys(propNameToEventType) as MapEventPropName[];\n\nexport type MapEvent<T = unknown> = {\n  type: string;\n  map: google.maps.Map;\n  detail: T;\n\n  stoppable: boolean;\n  stop: () => void;\n  domEvent?: MouseEvent | TouchEvent | PointerEvent | KeyboardEvent | Event;\n};\n\nexport type MapMouseEvent = MapEvent<{\n  latLng: google.maps.LatLngLiteral | null;\n  placeId: string | null;\n}>;\n\nexport type MapCameraChangedEvent = MapEvent<{\n  center: google.maps.LatLngLiteral;\n  bounds: google.maps.LatLngBoundsLiteral;\n  zoom: number;\n  heading: number;\n  tilt: number;\n}>;\n", "export function isLatLngLiteral(\n  obj: unknown\n): obj is google.maps.LatLngLiteral {\n  if (!obj || typeof obj !== 'object') return false;\n  if (!('lat' in obj && 'lng' in obj)) return false;\n\n  return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\n", "import {useEffect, useLayoutEffect} from 'react';\nimport {MapProps} from '@vis.gl/react-google-maps';\nimport {InternalCameraStateRef} from './use-internal-camera-state';\nimport {isLatLngLiteral} from '../../libraries/is-lat-lng-literal';\n\n/**\n * Internal hook to update the map-options and camera parameters when\n * props are changed.\n *\n * @param map the map instance\n * @param cameraStateRef stores the last values seen during dispatch into the\n * react-application in useMapEvents(). We can safely assume that we\n * don't need to feed these values back into the map.\n * @param mapProps the props to update the map-instance with\n * @internal\n */\nexport function useMapOptions(\n  map: google.maps.Map | null,\n  cameraStateRef: InternalCameraStateRef,\n  mapProps: MapProps\n) {\n  const {center: rawCenter, zoom, heading, tilt, ...mapOptions} = mapProps;\n  const center = rawCenter\n    ? isLatLngLiteral(rawCenter)\n      ? rawCenter\n      : rawCenter.toJSON()\n    : null;\n  const lat = center && center.lat;\n  const lng = center && center.lng;\n\n  /* eslint-disable react-hooks/exhaustive-deps --\n   *\n   * The following effects aren't triggered when the map is changed.\n   * In that case, the values will be or have been passed to the map\n   * constructor as mapOptions.\n   */\n\n  // update the map options when mapOptions is changed\n  // Note: due to the destructuring above, mapOptions will be seen as changed\n  //   with every re-render, so we're boldly assuming the maps-api will properly\n  //   deal with unchanged option-values passed into setOptions.\n  useEffect(() => {\n    if (!map) return;\n\n    // Changing the mapId via setOptions will trigger an error-message.\n    // We will re-create the map-instance in that case anyway, so we\n    // remove it here to avoid this error-message.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {mapId, ...opts} = mapOptions;\n    map.setOptions(opts);\n  }, [mapOptions]);\n\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(lat) || !Number.isFinite(lng)) return;\n    if (\n      cameraStateRef.current.center.lat === lat &&\n      cameraStateRef.current.center.lng === lng\n    )\n      return;\n\n    map.moveCamera({center: {lat: lat as number, lng: lng as number}});\n  }, [lat, lng]);\n\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(zoom)) return;\n    if (cameraStateRef.current.zoom === zoom) return;\n\n    map.moveCamera({zoom: zoom as number});\n  }, [zoom]);\n\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(heading)) return;\n    if (cameraStateRef.current.heading === heading) return;\n\n    map.moveCamera({heading: heading as number});\n  }, [heading]);\n\n  useLayoutEffect(() => {\n    if (!map || !Number.isFinite(tilt)) return;\n    if (cameraStateRef.current.tilt === tilt) return;\n\n    map.moveCamera({tilt: tilt as number});\n  }, [tilt]);\n  /* eslint-enable react-hooks/exhaustive-deps */\n}\n", "import {useLayoutEffect} from 'react';\n\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */\nexport function useDeckGLCameraUpdate(\n  map: google.maps.Map | null,\n  viewState: Record<string, unknown> | undefined\n) {\n  useLayoutEffect(() => {\n    if (!map || !viewState) {\n      return;\n    }\n\n    // FIXME: this should probably be extracted into a seperate hook that only\n    //  runs once when first seeing a deck.gl viewState update and resets\n    //  again. Maybe even use a seperate prop (`<Map controlled />`) instead.\n    map.setOptions({\n      gestureHandling: 'none',\n      keyboardShortcuts: false,\n      disableDefaultUI: true\n    });\n\n    const {\n      latitude,\n      longitude,\n      bearing: heading,\n      pitch: tilt,\n      zoom\n    } = viewState as Record<string, number>;\n\n    map.moveCamera({\n      center: {lat: latitude, lng: longitude},\n      heading,\n      tilt,\n      zoom: zoom + 1\n    });\n  }, [map, viewState]);\n}\n", "/* eslint-disable complexity */\nimport React, {\n  CSSProperties,\n  PropsWithChildren,\n  Ref,\n  useContext,\n  useEffect,\n  useMemo,\n  useState\n} from 'react';\n\nimport {APIProviderContext, APIProviderContextValue} from '../api-provider';\n\nimport {useApiIsLoaded} from '../../hooks/use-api-is-loaded';\nimport {logErrorOnce} from '../../libraries/errors';\nimport {useCallbackRef} from '../../libraries/use-callback-ref';\nimport {MapEventProps, useMapEvents} from './use-map-events';\nimport {useMapOptions} from './use-map-options';\nimport {useDeckGLCameraUpdate} from './use-deckgl-camera-update';\nimport {useInternalCameraState} from './use-internal-camera-state';\n\nexport interface GoogleMapsContextValue {\n  map: google.maps.Map | null;\n}\nexport const GoogleMapsContext =\n  React.createContext<GoogleMapsContextValue | null>(null);\n\n/**\n * Props for the Google Maps Map Component\n */\nexport type MapProps = google.maps.MapOptions &\n  MapEventProps & {\n    style?: CSSProperties;\n    /**\n     * Adds custom style to the map by passing a css class.\n     */\n    className?: string;\n    /**\n     * Adds initial bounds to the map as an alternative to specifying the center/zoom of the map.\n     * Calls the fitBounds method internally https://developers.google.com/maps/documentation/javascript/reference/map?hl=en#Map-Methods\n     */\n    initialBounds?: google.maps.LatLngBounds | google.maps.LatLngBoundsLiteral;\n    /**\n     * An id that is added to the map. Needed when using more than one Map component.\n     * This is also needed to reference the map inside the useMap hook.\n     */\n    id?: string;\n    /**\n     * Viewport from deck.gl\n     */\n    viewport?: unknown;\n    /**\n     * View state from deck.gl\n     */\n    viewState?: Record<string, unknown>;\n    /**\n     * Initial View State from deck.gl\n     */\n    initialViewState?: Record<string, unknown>;\n  };\n\n/**\n * Component to render a Google Maps map\n */\nexport const Map = (props: PropsWithChildren<MapProps>) => {\n  const {children, id, className, style, viewState, viewport} = props;\n\n  const context = useContext(APIProviderContext);\n\n  if (!context) {\n    throw new Error(\n      '<Map> can only be used inside an <ApiProvider> component.'\n    );\n  }\n\n  const [map, mapRef] = useMapInstance(props, context);\n  const cameraStateRef = useInternalCameraState();\n  useMapOptions(map, cameraStateRef, props);\n  useMapEvents(map, cameraStateRef, props);\n  useDeckGLCameraUpdate(map, viewState);\n\n  const isViewportSet = useMemo(() => Boolean(viewport), [viewport]);\n  const combinedStyle: CSSProperties = useMemo(\n    () => ({\n      width: '100%',\n      height: '100%',\n\n      // when using deckgl, the map should be sent to the back\n      zIndex: isViewportSet ? -1 : 0,\n      ...style\n    }),\n    [style, isViewportSet]\n  );\n\n  return (\n    <div\n      ref={mapRef}\n      data-testid={'map'}\n      style={className ? undefined : combinedStyle}\n      className={className}\n      {...(id ? {id} : {})}>\n      {map ? (\n        <GoogleMapsContext.Provider value={{map}}>\n          {children}\n        </GoogleMapsContext.Provider>\n      ) : null}\n    </div>\n  );\n};\nMap.deckGLViewProps = true;\n\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */\nfunction useMapInstance(\n  props: MapProps,\n  context: APIProviderContextValue\n): readonly [map: google.maps.Map | null, containerRef: Ref<HTMLDivElement>] {\n  const apiIsLoaded = useApiIsLoaded();\n  const [map, setMap] = useState<google.maps.Map | null>(null);\n  const [container, containerRef] = useCallbackRef<HTMLDivElement>();\n\n  const {\n    id,\n    initialBounds,\n\n    ...mapOptions\n  } = props;\n\n  // create the map instance and register it in the context\n  useEffect(\n    () => {\n      if (!container || !apiIsLoaded) return;\n\n      const {addMapInstance, removeMapInstance} = context;\n      const newMap = new google.maps.Map(container, mapOptions);\n      setMap(newMap);\n      addMapInstance(newMap, id);\n\n      if (initialBounds) {\n        newMap.fitBounds(initialBounds);\n      }\n\n      return () => {\n        if (!container || !apiIsLoaded) return;\n\n        // remove all event-listeners to minimize memory-leaks\n        google.maps.event.clearInstanceListeners(newMap);\n\n        setMap(null);\n        removeMapInstance(id);\n      };\n    },\n\n    // FIXME: we should rethink if it could be possible to keep the state\n    //   around when a map gets re-initialized (id or mapId changed). This\n    //   should keep the viewport as it is (so also no initial viewport in\n    //   this case) and any added features should of course get re-added as\n    //   well.\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [id, container, apiIsLoaded, props.mapId]\n  );\n\n  // report an error if the same map-id is used multiple times\n  useEffect(() => {\n    if (!id) return;\n\n    const {mapInstances} = context;\n\n    if (mapInstances[id] && mapInstances[id] !== map) {\n      logErrorOnce(\n        `The map id '${id}' seems to have been used multiple times. ` +\n          'This can lead to unexpected problems when accessing the maps. ' +\n          'Please use unique ids for all <Map> components.'\n      );\n    }\n  }, [id, context, map]);\n\n  return [map, containerRef] as const;\n}\n", "import {useContext, useEffect} from 'react';\n\nimport {APIProviderContext} from '../components/api-provider';\nimport {useApiIsLoaded} from './use-api-is-loaded';\n\ninterface ApiLibraries {\n  core: google.maps.CoreLibrary;\n  maps: google.maps.MapsLibrary;\n  places: google.maps.PlacesLibrary;\n  geocoding: google.maps.GeocodingLibrary;\n  routes: google.maps.RoutesLibrary;\n  marker: google.maps.MarkerLibrary;\n  geometry: google.maps.GeometryLibrary;\n  elevation: google.maps.ElevationLibrary;\n  streetView: google.maps.StreetViewLibrary;\n  journeySharing: google.maps.JourneySharingLibrary;\n  drawing: google.maps.DrawingLibrary;\n  visualization: google.maps.VisualizationLibrary;\n}\n\nexport function useMapsLibrary<\n  K extends keyof ApiLibraries,\n  V extends ApiLibraries[K]\n>(name: K): V | null;\n\nexport function useMapsLibrary(name: string) {\n  const apiIsLoaded = useApiIsLoaded();\n  const ctx = useContext(APIProviderContext);\n\n  useEffect(() => {\n    if (!apiIsLoaded || !ctx) return;\n\n    // Trigger loading the libraries via our proxy-method.\n    // The returned promise is ignored, since importLibrary will update loadedLibraries\n    // list in the context, triggering a re-render.\n    void ctx.importLibrary(name);\n  }, [apiIsLoaded, ctx?.importLibrary]);\n\n  return ctx?.loadedLibraries[name] || null;\n}\n", "/* eslint-disable complexity */\nimport React, {\n  Children,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useState\n} from 'react';\n\nimport {createPortal} from 'react-dom';\nimport {GoogleMapsContext} from './map';\n\nimport type {Ref, PropsWithChildren} from 'react';\nimport {useMapsLibrary} from '../hooks/use-maps-library';\n\nexport interface AdvancedMarkerContextValue {\n  marker: google.maps.marker.AdvancedMarkerElement;\n}\n\nexport const AdvancedMarkerContext =\n  React.createContext<AdvancedMarkerContextValue | null>(null);\n\ntype AdvancedMarkerEventProps = {\n  onClick?: (e: google.maps.MapMouseEvent) => void;\n  onDrag?: (e: google.maps.MapMouseEvent) => void;\n  onDragStart?: (e: google.maps.MapMouseEvent) => void;\n  onDragEnd?: (e: google.maps.MapMouseEvent) => void;\n};\n\nexport type AdvancedMarkerProps = PropsWithChildren<\n  Omit<google.maps.marker.AdvancedMarkerElementOptions, 'gmpDraggable'> &\n    AdvancedMarkerEventProps & {\n      /**\n       * className to add a class to the advanced marker element\n       * Can only be used with HTML Marker content\n       */\n      className?: string;\n      draggable?: boolean;\n    }\n>;\n\nexport type AdvancedMarkerRef = google.maps.marker.AdvancedMarkerElement | null;\nfunction useAdvancedMarker(props: AdvancedMarkerProps) {\n  const [marker, setMarker] =\n    useState<google.maps.marker.AdvancedMarkerElement | null>(null);\n  const [contentContainer, setContentContainer] =\n    useState<HTMLDivElement | null>(null);\n\n  const map = useContext(GoogleMapsContext)?.map;\n  const markerLibrary = useMapsLibrary('marker');\n\n  const {\n    children,\n    className,\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    collisionBehavior,\n    draggable,\n    position,\n    title,\n    zIndex\n  } = props;\n\n  const numChilds = Children.count(children);\n\n  // create marker instance and add it to the map when map becomes available\n  useEffect(() => {\n    if (!map || !markerLibrary) return;\n\n    const newMarker = new markerLibrary.AdvancedMarkerElement();\n    newMarker.map = map;\n\n    setMarker(newMarker);\n\n    // create container for marker content if there are children\n    if (numChilds > 0) {\n      const el = document.createElement('div');\n      if (className) el.classList.add(className);\n\n      newMarker.content = el;\n\n      setContentContainer(el);\n    }\n\n    return () => {\n      newMarker.map = null;\n      setMarker(null);\n      setContentContainer(null);\n    };\n  }, [map, markerLibrary, numChilds]);\n\n  // bind all marker events\n  useEffect(() => {\n    if (!marker) return;\n\n    const m = marker;\n\n    if (onClick) marker.addListener('click', onClick);\n    if (onDrag) marker.addListener('drag', onDrag);\n    if (onDragStart) marker.addListener('dragstart', onDragStart);\n    if (onDragEnd) marker.addListener('dragend', onDragEnd);\n\n    if ((onDrag || onDragStart || onDragEnd) && !draggable) {\n      console.warn(\n        'You need to set the marker to draggable to listen to drag-events.'\n      );\n    }\n\n    return () => {\n      google.maps.event.clearInstanceListeners(m);\n    };\n  }, [marker, draggable, onClick, onDragStart, onDrag, onDragEnd]);\n\n  // update other marker props when changed\n  useEffect(() => {\n    if (!marker) return;\n\n    if (position !== undefined) marker.position = position;\n    if (draggable !== undefined) marker.gmpDraggable = draggable;\n    if (collisionBehavior !== undefined)\n      marker.collisionBehavior = collisionBehavior;\n    if (zIndex !== undefined) marker.zIndex = zIndex;\n    if (typeof title === 'string') marker.title = title;\n  }, [marker, position, draggable, collisionBehavior, zIndex, title]);\n\n  return [marker, contentContainer] as const;\n}\n\nexport const AdvancedMarker = forwardRef(\n  (props: AdvancedMarkerProps, ref: Ref<AdvancedMarkerRef>) => {\n    const {children} = props;\n    const [marker, contentContainer] = useAdvancedMarker(props);\n\n    useImperativeHandle(ref, () => marker, [marker]);\n\n    if (!marker) {\n      return null;\n    }\n\n    return (\n      <AdvancedMarkerContext.Provider value={{marker}}>\n        {contentContainer !== null && createPortal(children, contentContainer)}\n      </AdvancedMarkerContext.Provider>\n    );\n  }\n);\n\nexport function useAdvancedMarkerRef() {\n  const [marker, setMarker] =\n    useState<google.maps.marker.AdvancedMarkerElement | null>(null);\n\n  const refCallback = useCallback((m: AdvancedMarkerRef | null) => {\n    setMarker(m);\n  }, []);\n\n  return [refCallback, marker] as const;\n}\n", "/* eslint-disable complexity */\nimport React, {PropsWithChildren, useContext, useEffect, useState} from 'react';\nimport {createPortal} from 'react-dom';\n\nimport {GoogleMapsContext} from './map';\n\n/**\n * Props for the Info Window Component\n */\nexport type InfoWindowProps = google.maps.InfoWindowOptions & {\n  onCloseClick?: () => void;\n  anchor?: google.maps.Marker | google.maps.marker.AdvancedMarkerElement | null;\n};\n\n/**\n * Component to render a Google Maps Info Window\n */\nexport const InfoWindow = (props: PropsWithChildren<InfoWindowProps>) => {\n  const {children, anchor, onCloseClick, ...infoWindowOptions} = props;\n  const map = useContext(GoogleMapsContext)?.map;\n\n  const [contentContainer, setContentContainer] =\n    useState<HTMLDivElement | null>(null);\n\n  // create infowindow once map is available\n  useEffect(() => {\n    if (!map) return;\n\n    const infoWindow = new google.maps.InfoWindow(infoWindowOptions);\n\n    // Add content to info window\n    const el = document.createElement('div');\n    infoWindow.setContent(el);\n    infoWindow.open({map, anchor});\n\n    if (onCloseClick) {\n      infoWindow.addListener('closeclick', () => {\n        onCloseClick();\n      });\n    }\n\n    setContentContainer(el);\n\n    // Cleanup info window and event listeners on unmount\n    return () => {\n      google.maps.event.clearInstanceListeners(infoWindow);\n\n      infoWindow.close();\n      el.remove();\n\n      setContentContainer(null);\n    };\n  }, [map, children, anchor]);\n\n  return (\n    <>{contentContainer !== null && createPortal(children, contentContainer)}</>\n  );\n};\n", "import {useContext} from 'react';\n\nimport {APIProviderContext} from '../components/api-provider';\nimport {GoogleMapsContext} from '../components/map';\nimport {logErrorOnce} from '../libraries/errors';\n\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */\nexport const useMap = (id: string | null = null): google.maps.Map | null => {\n  const ctx = useContext(APIProviderContext);\n  const {map} = useContext(GoogleMapsContext) || {};\n\n  if (ctx === null) {\n    logErrorOnce(\n      'useMap(): failed to retrieve APIProviderContext. ' +\n        'Make sure that the <APIProvider> component exists and that the ' +\n        'component you are calling `useMap()` from is a sibling of the ' +\n        '<APIProvider>.'\n    );\n\n    return null;\n  }\n\n  const {mapInstances} = ctx;\n\n  // if an id is specified, the corresponding map or null is returned\n  if (id !== null) return mapInstances[id] || null;\n\n  // otherwise, return the closest ancestor\n  if (map) return map;\n\n  // finally, return the default map instance\n  return mapInstances['default'] || null;\n};\n", "import {useEffect, useMemo} from 'react';\nimport {createPortal} from 'react-dom';\nimport {useMap} from '../hooks/use-map';\n\nimport type {PropsWithChildren} from 'react';\n\ntype MapControlProps = PropsWithChildren<{\n  position: ControlPosition;\n}>;\n\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nexport const ControlPosition = {\n  TOP_LEFT: 1,\n  TOP_CENTER: 2,\n  TOP: 2,\n  TOP_RIGHT: 3,\n  LEFT_CENTER: 4,\n  LEFT_TOP: 5,\n  LEFT: 5,\n  LEFT_BOTTOM: 6,\n  RIGHT_TOP: 7,\n  RIGHT: 7,\n  RIGHT_CENTER: 8,\n  RIGHT_BOTTOM: 9,\n  BOTTOM_LEFT: 10,\n  BOTTOM_CENTER: 11,\n  BOTTOM: 11,\n  BOTTOM_RIGHT: 12,\n  CENTER: 13,\n  BLOCK_START_INLINE_START: 14,\n  BLOCK_START_INLINE_CENTER: 15,\n  BLOCK_START_INLINE_END: 16,\n  INLINE_START_BLOCK_CENTER: 17,\n  INLINE_START_BLOCK_START: 18,\n  INLINE_START_BLOCK_END: 19,\n  INLINE_END_BLOCK_START: 20,\n  INLINE_END_BLOCK_CENTER: 21,\n  INLINE_END_BLOCK_END: 22,\n  BLOCK_END_INLINE_START: 23,\n  BLOCK_END_INLINE_CENTER: 24,\n  BLOCK_END_INLINE_END: 25\n} as const;\nexport type ControlPosition =\n  (typeof ControlPosition)[keyof typeof ControlPosition];\n\nexport const MapControl = ({children, position}: MapControlProps) => {\n  const controlContainer = useMemo(() => document.createElement('div'), []);\n  const map = useMap();\n\n  useEffect(() => {\n    if (!map) return;\n\n    const controls = map.controls[position];\n\n    controls.push(controlContainer);\n\n    return () => {\n      const index = controls.getArray().indexOf(controlContainer);\n      controls.removeAt(index);\n    };\n  }, [map, position]);\n\n  return createPortal(children, controlContainer);\n};\n", "/* eslint-disable complexity */\nimport React, {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useState\n} from 'react';\n\nimport {GoogleMapsContext} from './map';\n\nimport type {Ref} from 'react';\n\ntype MarkerEventProps = {\n  onClick?: (e: google.maps.MapMouseEvent) => void;\n  onDrag?: (e: google.maps.MapMouseEvent) => void;\n  onDragStart?: (e: google.maps.MapMouseEvent) => void;\n  onDragEnd?: (e: google.maps.MapMouseEvent) => void;\n  onMouseOver?: (e: google.maps.MapMouseEvent) => void;\n  onMouseOut?: (e: google.maps.MapMouseEvent) => void;\n};\n\nexport type MarkerProps = google.maps.MarkerOptions & MarkerEventProps;\n\nexport type MarkerRef = Ref<google.maps.Marker | null>;\n\nfunction useMarker(props: MarkerProps) {\n  const [marker, setMarker] = useState<google.maps.Marker | null>(null);\n  const map = useContext(GoogleMapsContext)?.map;\n\n  const {\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    onMouseOver,\n    onMouseOut,\n    ...markerOptions\n  } = props;\n\n  const {position, draggable} = markerOptions;\n\n  // create marker instance and add to the map once the map is available\n  useEffect(() => {\n    if (!map) {\n      if (map === undefined)\n        console.error('<Marker> has to be inside a Map component.');\n\n      return;\n    }\n\n    const newMarker = new google.maps.Marker(markerOptions);\n    newMarker.setMap(map);\n    setMarker(newMarker);\n\n    return () => {\n      newMarker.setMap(null);\n      setMarker(null);\n    };\n  }, [map]);\n\n  // attach and re-attach event-handlers when any of the properties change\n  useEffect(() => {\n    if (!marker) return;\n\n    const m = marker;\n\n    // Add event listeners\n    if (onClick) m.addListener('click', onClick);\n    if (onDrag) m.addListener('drag', onDrag);\n    if (onDragStart) m.addListener('dragstart', onDragStart);\n    if (onDragEnd) m.addListener('dragend', onDragEnd);\n    if (onMouseOver) m.addListener('mouseover', onMouseOver);\n    if (onMouseOut) m.addListener('mouseout', onMouseOut);\n\n    marker.setDraggable(Boolean(draggable));\n\n    return () => {\n      google.maps.event.clearInstanceListeners(m);\n    };\n  }, [\n    marker,\n    draggable,\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    onMouseOver,\n    onMouseOut\n  ]);\n\n  // update markerOptions (note the dependencies aren't properly checked\n  // here, we just assume that setOptions is smart enough to not waste a\n  // lot of time updating values that didn't change)\n  useEffect(() => {\n    if (!marker) return;\n    if (markerOptions) marker.setOptions(markerOptions);\n  }, [marker, markerOptions]);\n\n  // update position when changed\n  useEffect(() => {\n    // Should not update position when draggable\n    if (draggable || !position || !marker) return;\n\n    marker.setPosition(position);\n  }, [draggable, position, marker]);\n\n  return marker;\n}\n\n/**\n * Component to render a Google Maps Marker on a map\n */\nexport const Marker = forwardRef((props: MarkerProps, ref: MarkerRef) => {\n  const marker = useMarker(props);\n\n  useImperativeHandle(ref, () => marker, [marker]);\n\n  return <></>;\n});\n\nexport function useMarkerRef() {\n  const [marker, setMarker] = useState<google.maps.Marker | null>(null);\n\n  const refCallback = useCallback((m: google.maps.Marker | null) => {\n    setMarker(m);\n  }, []);\n\n  return [refCallback, marker] as const;\n}\n", "import {\n  Children,\n  PropsWithChildren,\n  useContext,\n  useEffect,\n  useMemo\n} from 'react';\nimport {AdvancedMarkerContext} from './advanced-marker';\nimport {createPortal} from 'react-dom';\nimport {logErrorOnce} from '../libraries/errors';\n\n/**\n * Props for the Pin component\n */\nexport type PinProps = google.maps.marker.PinElementOptions;\n\n/**\n * Component to render a google maps marker Pin View\n */\nexport const Pin = (props: PropsWithChildren<PinProps>) => {\n  const advancedMarker = useContext(AdvancedMarkerContext)?.marker;\n  const glyphContainer = useMemo(() => document.createElement('div'), []);\n\n  // Create Pin View instance\n  useEffect(() => {\n    if (!advancedMarker) {\n      if (advancedMarker === undefined) {\n        console.error(\n          'The <Pin> component can only be used inside <AdvancedMarker>.'\n        );\n      }\n\n      return;\n    }\n\n    if (props.glyph && props.children) {\n      logErrorOnce(\n        'The <Pin> component only uses children to render the glyph if both the glyph property and children are present.'\n      );\n    }\n\n    if (Children.count(props.children) > 1) {\n      logErrorOnce(\n        'Passing multiple children to the <Pin> component might lead to unexpected results.'\n      );\n    }\n\n    const pinViewOptions: google.maps.marker.PinElementOptions = {\n      ...props\n    };\n\n    const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n\n    // Set glyph to glyph container if children are present (rendered via portal).\n    // If both props.glyph and props.children are present, props.children takes priority.\n    if (props.children) {\n      pinElement.glyph = glyphContainer;\n    }\n\n    // Set content of Advanced Marker View to the Pin View element\n    advancedMarker.content = pinElement.element;\n  }, [advancedMarker, props]);\n\n  return createPortal(props.children, glyphContainer);\n};\n", "import {useState, useRef, useEffect} from 'react';\n\nimport {useApiIsLoaded} from './use-api-is-loaded';\n\nexport interface AutocompleteProps {\n  inputField: HTMLInputElement | null;\n  options?: google.maps.places.AutocompleteOptions;\n  onPlaceChanged: (place: google.maps.places.PlaceResult) => void;\n}\n\n/**\n * Hook to get a Google Maps Places Autocomplete instance\n * monitoring an input field\n */\nexport const useAutocomplete = (\n  props: AutocompleteProps\n): google.maps.places.Autocomplete | null => {\n  const {inputField, options, onPlaceChanged} = props;\n\n  const googleMapsAPIIsLoaded = useApiIsLoaded();\n\n  const placeChangedHandler = useRef(onPlaceChanged);\n\n  const [autocomplete, setAutocomplete] =\n    useState<google.maps.places.Autocomplete | null>(null);\n\n  // Initializes the Google Maps Places Autocomplete\n  useEffect(() => {\n    // Wait for the Google Maps API and input element to be initialized\n    if (!googleMapsAPIIsLoaded || !inputField) return;\n\n    // FIXME: add dynamic loading for required libraries\n    if (!google.maps.places) {\n      console.error(\n        'Google Maps Places library is missing. ' +\n          'Please add the places library to the props of the <ApiProvider> ' +\n          'component.'\n      );\n\n      return;\n    }\n\n    // Create Autocomplete instance\n    const autocompleteInstance = new google.maps.places.Autocomplete(\n      inputField,\n      options\n    );\n\n    setAutocomplete(autocompleteInstance);\n\n    // Add places change listener to Autocomplete\n    autocompleteInstance.addListener('place_changed', () => {\n      const place = autocompleteInstance.getPlace();\n      if (placeChangedHandler.current) placeChangedHandler.current(place);\n    });\n\n    // Clear listeners on unmount\n    return () => {\n      if (autocompleteInstance && typeof google.maps === 'object') {\n        google.maps.event.clearInstanceListeners(autocompleteInstance);\n      }\n    };\n  }, [googleMapsAPIIsLoaded, inputField, options]);\n\n  return autocomplete;\n};\n", "/**\n * A typescript assertion function used in cases where typescript has to be\n * convinced that the object in question can not be null.\n *\n * @param value\n * @param message\n */\nexport function assertNotNull<TValue>(\n  value: TValue,\n  message = 'assertion failed'\n): asserts value is NonNullable<TValue> {\n  if (value === null || value === undefined) {\n    throw Error(message);\n  }\n}\n", "import {useMemo, useEffect, useCallback} from 'react';\n\nimport {useApiIsLoaded} from './use-api-is-loaded';\nimport {useMap} from './use-map';\nimport {assertNotNull} from '../libraries/assert-not-null';\n\nexport interface DirectionsServiceHookOptions {\n  mapId?: string;\n  renderOnMap?: boolean;\n  renderOptions?: google.maps.DirectionsRendererOptions;\n}\n\ninterface DirectionsServiceHookReturns {\n  directionsService: google.maps.DirectionsService | null;\n  directionsRenderer: google.maps.DirectionsRenderer | null;\n  renderRoute:\n    | ((\n        request: google.maps.DirectionsRequest\n      ) => Promise<google.maps.DirectionsResult>)\n    | null;\n  setRenderedRouteIndex: ((index: number) => void) | null;\n}\n\nconst useDirectionsRenderer = (\n  mapId: string | null,\n  renderOnMap?: boolean,\n  renderOptions?: google.maps.DirectionsRendererOptions\n) => {\n  const map = useMap(mapId);\n\n  // create the renderer instance\n  const directionsRenderer = useMemo(\n    () => {\n      if (!map || !renderOnMap) return null;\n\n      const renderer = new google.maps.DirectionsRenderer(renderOptions);\n      renderer.setMap(map);\n\n      return renderer;\n    },\n    // note: no dependency on renderOptions since those are handled in the\n    // next effect.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [map, renderOnMap]\n  );\n\n  useEffect(\n    () => {\n      if (!directionsRenderer) return;\n\n      directionsRenderer.setOptions(renderOptions || {});\n    },\n    // note: directionsRenderer dependency isn't needed since the\n    // renderOptions will be set on initialization when creating the renderer.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [renderOptions]\n  );\n\n  return directionsRenderer;\n};\n\n/**\n * Hook to get Google Maps Places Directions Service instance\n */\nexport const useDirectionsService = (\n  props: DirectionsServiceHookOptions = {}\n): DirectionsServiceHookReturns => {\n  const {mapId = null, renderOnMap, renderOptions} = props;\n  const isApiLoaded = useApiIsLoaded();\n\n  // Creates a Directions Service instance\n  const directionsService = useMemo(() => {\n    // Wait for Google Maps API to be loaded\n    if (!isApiLoaded) return null;\n\n    return new google.maps.DirectionsService();\n  }, [isApiLoaded]);\n\n  // create the renderer instance\n  const directionsRenderer = useDirectionsRenderer(\n    mapId,\n    renderOnMap,\n    renderOptions\n  );\n\n  // Custom Directions route request followed by directions rendering\n  const renderRoute = useCallback(\n    async (\n      request: google.maps.DirectionsRequest\n    ): Promise<google.maps.DirectionsResult> => {\n      // findAndRenderRoute() isn't callable when either directions\n      // service or renderer aren't ready\n      assertNotNull(directionsService);\n      assertNotNull(directionsRenderer);\n\n      const result = await directionsService.route(request);\n      directionsRenderer.setDirections(result);\n\n      return result;\n    },\n    [directionsService, directionsRenderer]\n  );\n\n  // Renders directions route of given index\n  const setRenderedRouteIndex = (index: number) => {\n    assertNotNull(directionsRenderer);\n\n    directionsRenderer.setRouteIndex(index);\n  };\n\n  return {\n    directionsService,\n    directionsRenderer,\n    renderRoute: directionsService && directionsRenderer ? renderRoute : null,\n    setRenderedRouteIndex:\n      directionsService && directionsRenderer ? setRenderedRouteIndex : null\n  };\n};\n", "/* eslint-disable complexity */\nimport {useEffect, useState} from 'react';\nimport {useApiIsLoaded} from './use-api-is-loaded';\nimport {useMap} from './use-map';\n\nexport interface StreetViewPanoramaProps {\n  mapId?: string;\n  divElement?: HTMLElement | null;\n  position?: google.maps.LatLng | google.maps.LatLngLiteral;\n  pov?: google.maps.StreetViewPov;\n  zoom?: number;\n}\n\n/**\n * Hook to get Street View Panorama\n */\nexport const useStreetViewPanorama = (\n  props: StreetViewPanoramaProps = {}\n): google.maps.StreetViewPanorama | null => {\n  const {mapId, divElement, position, pov, zoom} = props;\n  const googleMapsAPIIsLoaded = useApiIsLoaded();\n  const map = useMap(mapId);\n\n  const [streetViewPanorama, setStreetViewPanorama] =\n    useState<google.maps.StreetViewPanorama | null>(null);\n\n  // Creates a Street View instance\n  useEffect(\n    () => {\n      if (!googleMapsAPIIsLoaded) return;\n\n      let pano: google.maps.StreetViewPanorama | null = null;\n      if (divElement) {\n        pano = new google.maps.StreetViewPanorama(divElement);\n      } else if (map) {\n        pano = map.getStreetView();\n      }\n\n      setStreetViewPanorama(pano);\n\n      if (!pano) return;\n      if (pov) pano.setPov(pov);\n      if (position) pano.setPosition(position);\n      if (zoom || zoom === 0) pano.setZoom(zoom);\n\n      return (): void => {\n        setStreetViewPanorama(null);\n\n        if (map) map.setStreetView(null);\n      };\n    },\n    // fixme: implement extra hook to update FOV when props change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [googleMapsAPIIsLoaded, map, divElement]\n  );\n\n  return streetViewPanorama;\n};\n", "const mapLinear = (x: number, a1: number, a2: number, b1: number, b2: number) =>\n  b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);\n\nconst getMapMaxTilt = (zoom: number) => {\n  if (zoom <= 10) {\n    return 30;\n  }\n  if (zoom >= 15.5) {\n    return 67.5;\n  }\n\n  // range [10...14]\n  if (zoom <= 14) {\n    return mapLinear(zoom, 10, 14, 30, 45);\n  }\n\n  // range [14...15.5]\n  return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n\n/**\n * Function to limit the tilt range of the google maps map when updating the view state\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const limitTiltRange = ({viewState}: any) => {\n  const pitch = viewState.pitch;\n  const gmZoom = viewState.zoom + 1;\n  const maxTilt = getMapMaxTilt(gmZoom);\n\n  return {...viewState, fovy: 25, pitch: Math.min(maxTilt, pitch)};\n};\n"],
  "mappings": "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",
  "names": ["MAPS_API_BASE_URL", "GoogleMapsApiLoader", "load", "params", "_window$google", "libraries", "split", "serializedParams", "serializeParams", "window", "google", "maps", "importLibrary", "__googleMapsApiParams__", "initImportLibrary", "console", "warn", "lib", "v", "key", "language", "region", "authReferrerPolicy", "solutionChannel", "join", "apiPromise", "loadApi", "library", "Promise", "resolve", "reject", "_document$querySelect", "scriptElement", "document", "createElement", "urlParams", "URLSearchParams", "value", "Object", "entries", "urlParamName", "replace", "t", "toLowerCase", "set", "src", "toString", "__googleMapsCallback__", "onerror", "Error", "nonce", "querySelector", "head", "append", "libraryName", "then", "APILoadingStatus", "NOT_LOADED", "LOADING", "LOADED", "FAILED", "APIProviderContext", "React", "createContext", "useMapInstances", "mapInstances", "setMapInstances", "useState", "addMapInstance", "mapInstance", "id", "instances", "_extends", "removeMapInstance", "_ref", "remaining", "_objectWithoutPropertiesLoose", "map", "_toPropertyKey", "clearMapInstances", "useGoogleMapsApiLoader", "props", "onLoad", "apiKey", "otherApiParams", "_excluded", "status", "setStatus", "loadedLibraries", "addLoadedLibrary", "useReducer", "action", "name", "librariesString", "useMemo", "JSON", "stringify", "useCallback", "_google", "res", "useEffect", "error", "APIProvider", "children", "loaderProps", "_excluded2", "Provider", "useApiLoadingStatus", "_useContext", "useContext", "useApiIsLoaded", "shownMessages", "Set", "logErrorOnce", "args", "has", "add", "useCallbackRef", "el", "setEl", "ref", "useInternalCameraState", "useRef", "center", "lat", "lng", "heading", "tilt", "zoom", "trackDispatchedEvent", "ev", "cameraStateRef", "cameraEvent", "detail", "current", "useMapEvents", "propName", "eventPropNames", "handler", "eventType", "propNameToEventType", "listener", "addListener", "mapEvent", "createMapEvent", "remove", "type", "srcEvent", "stoppable", "stop", "cameraEventTypes", "includes", "camEvent", "getCenter", "getZoom", "getHeading", "getTilt", "bounds", "getBounds", "Number", "isFinite", "toJSON", "north", "east", "south", "west", "mouseEventTypes", "_srcEvent$latLng", "mouseEvent", "domEvent", "latLng", "placeId", "onBoundsChanged", "onCenterChanged", "onClick", "onContextmenu", "onDblclick", "onDrag", "onDragend", "onDragstart", "onHeadingChanged", "onIdle", "onIsFractionalZoomEnabledChanged", "onMapCapabilitiesChanged", "onMapTypeIdChanged", "onMousemove", "onMouseout", "onMouseover", "onProjectionChanged", "onRenderingTypeChanged", "onTilesLoaded", "onTiltChanged", "onZoomChanged", "keys", "isLatLngLiteral", "obj", "useMapOptions", "mapProps", "rawCenter", "mapOptions", "opts", "setOptions", "useLayoutEffect", "moveCamera", "useDeckGLCameraUpdate", "viewState", "gestureHandling", "keyboardShortcuts", "disableDefaultUI", "latitude", "longitude", "bearing", "pitch", "GoogleMapsContext", "Map", "className", "style", "viewport", "context", "mapRef", "useMapInstance", "isViewportSet", "Boolean", "combinedStyle", "width", "height", "zIndex", "undefined", "deckGLViewProps", "apiIsLoaded", "setMap", "container", "containerRef", "initialBounds", "newMap", "fitBounds", "event", "clearInstanceListeners", "mapId", "useMapsLibrary", "ctx", "AdvancedMarkerContext", "useAdvancedMarker", "marker", "setMarker", "contentContainer", "setContentContainer", "markerLibrary", "onDragStart", "onDragEnd", "collisionBehavior", "draggable", "position", "title", "numChilds", "Children", "count", "newMarker", "AdvancedMarkerElement", "classList", "content", "m", "gmpDraggable", "AdvancedMarker", "forwardRef", "useImperativeHandle", "createPortal", "useAdvancedMarkerRef", "refCallback", "InfoWindow", "anchor", "onCloseClick", "infoWindowOptions", "infoWindow", "setContent", "open", "close", "Fragment", "useMap", "ControlPosition", "TOP_LEFT", "TOP_CENTER", "TOP", "TOP_RIGHT", "LEFT_CENTER", "LEFT_TOP", "LEFT", "LEFT_BOTTOM", "RIGHT_TOP", "RIGHT", "RIGHT_CENTER", "RIGHT_BOTTOM", "BOTTOM_LEFT", "BOTTOM_CENTER", "BOTTOM", "BOTTOM_RIGHT", "CENTER", "BLOCK_START_INLINE_START", "BLOCK_START_INLINE_CENTER", "BLOCK_START_INLINE_END", "INLINE_START_BLOCK_CENTER", "INLINE_START_BLOCK_START", "INLINE_START_BLOCK_END", "INLINE_END_BLOCK_START", "INLINE_END_BLOCK_CENTER", "INLINE_END_BLOCK_END", "BLOCK_END_INLINE_START", "BLOCK_END_INLINE_CENTER", "BLOCK_END_INLINE_END", "MapControl", "controlContainer", "controls", "push", "index", "getArray", "indexOf", "removeAt", "useMarker", "onMouseOver", "onMouseOut", "markerOptions", "Marker", "setDraggable", "setPosition", "useMarkerRef", "Pin", "advancedMarker", "glyphContainer", "glyph", "pinViewOptions", "pinElement", "PinElement", "element", "useAutocomplete", "inputField", "options", "onPlaceChanged", "googleMapsAPIIsLoaded", "placeChangedHandler", "autocomplete", "setAutocomplete", "places", "autocompleteInstance", "Autocomplete", "place", "getPlace", "assertNotNull", "message", "useDirectionsRenderer", "renderOnMap", "renderOptions", "directionsRenderer", "renderer", "DirectionsRenderer", "useDirectionsService", "isApiLoaded", "directionsService", "DirectionsService", "renderRoute", "request", "result", "route", "setDirections", "setRenderedRouteIndex", "setRouteIndex", "useStreetViewPanorama", "divElement", "pov", "streetViewPanorama", "setStreetViewPanorama", "pano", "StreetViewPanorama", "getStreetView", "setPov", "setZoom", "setStreetView", "mapLinear", "x", "a1", "a2", "b1", "b2", "getMapMaxTilt", "limitTiltRange", "gmZoom", "maxTilt", "fovy", "Math", "min"]
}
